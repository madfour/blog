## 一、JavaScript基础

### 一、变量与变量声明

> JS的数据类型有7种，其中基本类型6种，分别是`Boolean`,`NUll`,`Undefined`,`Number`,`String`,`Symbol`（ECMAScript6新提出）;然后对象`Object`一种。
>
> 在JS中，我们通过`var`关键字即可声明一个局部变量：
>
> ```javascript
> var foo = 42;    // foo is a Number now
> var foo = "bar"; // foo is a String now`
> ```
>
> 变量声明是如此简单，但请**注意**，变量声明中一旦缺失`var`关键字，那么声明的变量就是全局变量！
>
> 这样相当危险，因为你不知道这个变量会不会覆盖/污染某个全局变量，比如在一个基于`jQuery`的页面中写一句`$ = 'whatever';`很可能造成程序崩溃。过多的全局变量会加大引起冲突的可能。

### 二、作用域

> 1.**全局变量**：声明在函数外部的变量（所有没有var直接赋值的变量都属于全局变量）
>
> 2.**局部变量**：声明在函数内部的变量（所有没有var直接赋值的变量都属于全局变量）
>
> JS中变量申明分显式申明和隐式申明:
>
> ````javascript
> vari=100;//显式申明 
> i=100;//隐式申明 
> ````
>
> 在函数中使用var关键字进行显式申明的变量是做为局部变量，而没有用var关键字，使用直接赋值方式声明的是全局变量。　　 
>
> 当我们使用访问一个没有声明的变量时，JS会报错。而当我们给一个没有声明的变量赋值时，JS不会报错，相反它会认为我们是要隐式申明一个全局变量，这一点一定要注意。

#### 1、全局作用域

> 最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的：
>
> ```javascript
> var outerVar = "outer";
> function fn(){
> 	console.log(outerVar);
> }
> fn();//result:outer
> ```

#### 2、局部作用域

> 和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见的例如函数内部。
>
> `````` javascript
> function fn(){       
>     var innerVar = "inner";
> }
> fn();
> console.log(innerVar);// ReferenceError: innerVar is not defined
> ``````
>
> 函数内部声明变量的时候，一定要使用`var`命令。如果不用的话，实际上就是声明了一个全局变量！
>
> ``````javascript
> var scope = "global";
> function fn(){
>     console.log(scope);		//result:undefined
>     var scope = "local";
>     console.log(scope);		//result:local;
> }
> fn();
> ``````
>
> 第一个输出居然是`undefined`，原本以为它会访问外部的全局变量(`scope=”global”`)，但是并没有。这可以算是javascript的一个特点，**只要函数内定义了一个局部变量，函数在解析的时候都会将这个变量“提前声明”**：
>
> ``````javascript
> var scope = "global";
> function fn(){
>     var scope;		//提前声明了局部变量
>     console.log(scope);		//result:undefined
>     scope = "local";
>     console.log(scope);		//result:local;
> }
> fn();
> ``````
>
> 然而，也不能因此草率地将局部作用域定义为：用var声明的变量作用范围起止于花括号之间。 
>
> ES6之前javascript并没有所谓的块级作用域，
>
> javascript的作用域是相对函数而言的，可以称为**函数作用域**，
>
> ES6 可以使用 `let` 关键字或者 `const` 关键字来实现块级作用域。
>
> `let` 或 `const`声明的变量只在 `let` 或 `const`命令所在的代码块 {} 内有效，在 {} 之外不能访问。
>
> ``````javascript
> { 
>     let x = 2;
> }
> // 这里不能使用 x 变量
> ``````
>
> **let 关键字声明的变量，只在 let 命令所在的代码块 {} 内有效。**
>
> ``````javascript
> var x = 10;
> // 这里输出 x 为 10
> { 
>     let x = 2;
>     // 这里输出 x 为 2
> }
> // 这里输出 x 为 10
> ``````

#### 3、作用域链 

>https://www.cnblogs.com/mrzl/p/4415149.html
>
>在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象 。
>
>函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。
>
>其中一个内部属性是[[`Scope`]]，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为**函数的作用域链**，它决定了哪些数据能被函数访问。
>
>当一个函数创建后，它实际上保存一个作用域链，并且作用域链会被创建此函数的作用域中可访问的数据对象填充。例：
>
>    ``````javascript
>    function fnc(){
>    var num =1;
>    alert(num);
>}
>fnc();
>``````
>
>在函数fnc创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量。

#### 4、执行环境









## 二、Git命令

#### 创建版本库

````ruby
$ mkdir 文件名
$ cd 文件名
$ pwd	#显示当前目录
````

#### 通过`git init`命令把这个目录变成Git可以管理的仓库

````ruby
$ git init
````

#### 用命令`git add`告诉Git，把文件添加到仓库：

````ruby
$ git add 文件名
````

#### 用命令`git commit`告诉Git，把文件提交到仓库：

````ruby
$ git commit -m "提交说明"
````

> add 和commit -m 合用
>
> ````ruby
> git commit -a -m "提交说明"
> ````

> 提交说明可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。

#### git其它命令说明

````ruby
$ git status	#查看当前仓库的状态，会告诉我们那些文件被修改过，但还没提交的修改

$ git diff 		#查看所有本地文件更改。可以附加文件名，以仅显示一个文件的更改。

$ git log 		#查看所有提交历史记录。也可以用于具有git log -p **的文件。输入q退出。
#也可用 Git log --pretty=oneline   更方便查看

$ git blame **  #查看谁更改了**中的内容和时间。
    
$ git reflog 	#显示本地存储库HEAD的更改日志。有助于找到遗失的文件。

````

> 在Git中，用`HEAD`表示当前版本，也就是最新的提交`3628164...882e1e0`（注意我的提交ID和你的肯定不一样），上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个`^`比较容易数不过来，所以写成`HEAD~100`。

````ruby
$ git reset --hard HEAD^		#回退到上一个版本

#想要再找会之前的版本，只要上面的命令行窗口还没有被关掉 找到版本号的id
$ git reset  --hard 1094a
#版本号不必要写全，写前几位就可以(最好大于5位)，Git会自动去找

#当然，如果上面的命令窗口早已清除了，看不到版本号了，也是有后悔药吃的
$ git reflog		#用来记录你的每一次命令历史，以便确定要回到未来的哪个版本

````

> `git reset`、`git checkout`和`git revert`用于撤消对存储库所做更改的影响。这些命令可能很难理解。
>
> `git reset`和`git checkout`可用于提交和单个文件。
>
> `git revert`仅用于提交级别。
>
> 如果你只是处理尚未合并到协作远程工作中的本地提交，则可以使用这些命令中的任何一个。
>
> 如果你正在协作工作，并且需要撤销在远程分支中的提交，那么就使用`git revert`。

#### 工作区和暂存区

> **工作区**：就是在电脑里能看到的目录，比如`learngit`文件夹就是个工作区；
>
> **版本库**
>
> 工作区有一个隐藏目录`.git`，这个不算工作区，而是Git的版本库。
>
> Git的版本库中存了很多的东西，最重要的就是称为stage(或叫index)的**暂存区**，还有Git为我们自动创建的第一个分支`master`，以及指向`master`的一个指针`HEAD`。
>
> 前面我们把文件往Git版本库里添加的时候，是分两步执行的：
>
> 第一步：用`git add`把文件添加进去，实际就是把文件修改添加到暂存区；
>
> 第二部：用`git commit`提交更改，实际上就是把暂存区的所有内容提交到当前分支。
>
> 可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。

````ruby
#file 是文件名

$ git diff HEAD -- file 		#查看工作区和版本库里面最新版本的区别

$ git checkout -- file		#丢弃在工作区的修改

````

>命令`git checkout -- readme.txt`意思就是，把`readme.txt`文件在工作区的修改全部撤销，这里有两种情况：
>
>一种是`readme.txt`自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
>
>一种是`readme.txt`已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
>
>总之，就是让这个文件回到最近一次`git commit`或`git add`时的状态。
>
>`git checkout -- file`命令中的`--`很重要，没有`--`，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到`git checkout`命令。

#### 删除文件

一般情况下，通常直接在文件管理器中把没用的文件删了，或者用`rm`命令：

````ruby
$ rm 文件名
````

但因此，工作区和版本库就不一致了，通过`git status`命令知道哪些文件被删除了。

所以你有两个选择，

一是确实要从版本库中删除改文件，那就用`git rm`删掉，并且`git commit`:

````ruby
$ git rm 文件名
````

> 小提示：先手动删除文件，然后使用`git rm <file>`和`git add<file>`效果是一样的。

另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：

````ruby
$ git checkout -- 文件名
````

> `git checkout`其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。

> **注意：**从来没有被添加到版本库就被删除的文件，是无法恢复的！

#### 远程仓库(学习重点)

> 注册GitHub账号,由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：
>
> #####第一步：创建SSH Key。
>
> 在用户主目录下，看看有没有.ssh目录(如C:\Users\Y\.ssh)，若有且，该目录下还存在`id.rsa`和`id.rsa.pub`这两文件，则可以跳过这一步。若没有，就打开Shell（Windows下打开Git Bash），创建SSH Key:
>
> ````ruby
> $ ssh-keygen -t rsa -C "youremail@example.com"
> ````
>
> 把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。
>
> 如果一切顺利的话，可以在用户主目录里找到`.ssh`目录，里面有`id_rsa`和`id_rsa.pub`两个文件，这两个就是SSH Key的秘钥对，`id_rsa`是私钥，不能泄露出去，`id_rsa.pub`是公钥，可以放心地告诉任何人。
>
> ##### 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：
>
> 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴`id_rsa.pub`文件的内容,
>
> 点“Add Key”，你就应该看到已经添加的Key。
>
> > GitHub允许你添加多个Key，若有多个电脑，可把每台电脑的Key都添加到GitHub上，这样就可以在每台电脑上往GitHub推送了
>
> > 提示：在GitHub上免费托管的Git仓库，任何人都可见（但只有自己才能改）。
> >
> > 若不想别人可见，方法有二。一是交钱，让GitHub把公开的仓库变成私有的。二是自己动手，搭建一个Git服务器。

#### 添加远程仓库

> 现在的情景是，你已在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这连个仓库进行远程同步，这样Github上的仓库即可以作为备份，又可以让他人通过该仓库协作。

首先，登录GitHub，在右上角找到“New repository”(新储存库)，创建一个新的储存库。

> 例如创建一个learngit储存库

目前，在GitHub上的这个`learngit`仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。

现在，我们根据GitHub的提示，在本地的`learngit`仓库下运行命令：

````ruby

$ git remote add origin git@github.com:zjcLuKeer/learngit.git
#注意：把上面zjc8739替换成自己的GitHub账户名。

#添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。
#下一步，就可以把本地库的所有内容推送到远程库上：
$ git push -u origin master

````

把本地库的内容推送到远程，用`git push`命令，实际上是把当前分支`master`推送到远程。

由于远程库是空的，我们第一次推送`master`分支时，加上了`-u`参数，Git不但会把本地的`master`分支内容推送的远程新的`master`分支，还会把本地的`master`分支和远程的`master`分支关联起来，在以后的推送或者拉取时就可以简化命令。

推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样；

从现在起，只要本地作了提交，就可以通过命令：

````ruby
$ git push origin master
````

把本地`master`分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！

#### SSH警告

当你第一次使用Git的`clone`或者`push`命令连接GitHub时，会得到一个警告：

````ruby
The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.
RSA key fingerprint is xx.xx.xx.xx.xx.
Are you sure you want to continue connecting (yes/no)?
````

这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入`yes`回车即可。

Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了，

````ruby
Warning: Permanently added 'github.com' (RSA) to the list of known hosts.
````

这个警告只会出现一次，后面的操作就不会有任何警告了。

#### 从远程库克隆

使用命令`git clone`克隆一个本地库，例如：

````ruby
$ git clone git@github.com:zjcLuKeer/learngit.git
````

**小结**

要克隆一个仓库，首先必须知道仓库的地址，然后使用`git clone`命令克隆。

Git支持多种协议，包括`https`，但通过`ssh`支持的原生`git`协议速度最快。

#### 分支管理

##### 创建与合并分支

**实战举例**

> 首先，创建一个名字为`dev`的分支，然后切换到`dev`分支上：
>
> ````ruby
> $ git checkout -b dev
> ````
>
> > `git checkout`命令加上`-b`参数表示**创建并切换**，相当于以下两条命令：
> >
> > ````ruby
> > $ git branch dev
> > $ git checkout dev
> > ````
>
> 然后提交：
>
> ````ruby
> $ git add readme.txt 		
> $ git commit -m "branch test"
> ````
>
> 现在，`dev`分支的工作完成，我们就可以切换回`master`分支：
>
> ````ruby
> $ git checkout master
> ````
>
> 切回`master`分支后可以发现，之前在readme.txt文件中添加的内容不见了！
>
> 因为那个提交是在`dev`分支上的，而`master`分支此刻的提交点并没有改变。
>
> 现在，我们把`dev`分支的工作成果合并到`master`分支上：
>
> ````ruby
> $ git merge dev
> Updating d46f35e..b17d20e
> Fast-forward
>  readme.txt | 1 +
>  1 file changed, 1 insertion(+)
> ````
>
> `git merge`命令用于合并**指定分支**到**当前分支**，
>
> 合并后再次查看文件，可以发现和`dev`分支的最新提交是完全一样的。
>
> >注意到上面的`Fast-forward`信息，Git告诉我们，这次合并是“快进模式”，也就是直接把`master`指向`dev`的当前提交，所以合并速度非常快。
> >
> >当然，也不是每次合并都能`Fast-forward`，还会有其他方式和合并
>
> 合并完成后，可以安心删除`dev`分支
>
> ````ruby
> $ git branch -d dev
> ````
>
> 删除后，查看`branch`，就只剩下`master`分支了
>
> ````ruby
> $ git branch
> * master
> ````

**小结**

Git鼓励大量使用分支：

查看分支：`git branch`

创建分支：`git branch <name>`

切换分支：`git checkout <name>`

创建+切换分支：`git checkout -b <name>`

合并某分支到当前分支：`git merge <name>`

删除分支：`git branch -d <name>`



























